<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ApiUtilities.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s0</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.student.main.server</a> &gt; <span class="el_source">ApiUtilities.java</span></div><h1>ApiUtilities.java</h1><pre class="source lang-java linenums">package edu.brown.cs.student.main.server;

import com.squareup.moshi.JsonAdapter;
import com.squareup.moshi.JsonReader;
import com.squareup.moshi.Moshi;
import com.squareup.moshi.Types;
import edu.brown.cs.student.main.csvSearch.Container;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Type;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okio.Buffer;

/**
 * Class for serialization and deserialization.
 *
 * @param &lt;T&gt; for general json method
 */
public class ApiUtilities&lt;T&gt; {

  /**
   * Our APIUtilities class handles the main logic for serialization and deserialization for our
   * overarching program. Constructor doesnâ€™t have functionality itself. (i.e is empty)
   */
<span class="nc" id="L29">  public ApiUtilities() {}</span>

  /**
   * This is our main method for deserialization. fromJson takes a json and forms it into an
   * arrayList&lt;&gt;. This is used in the BroadBand handler to deserialize the output we get from
   * APIOutput.
   *
   * @param json JSON String
   * @return -&gt; an arraylist with the content provided via the JSON
   * @throws IOException throws an error if the info can't be deserialized
   */
  public static ArrayList&lt;List&lt;String&gt;&gt; fromJson(String json) throws IOException {
<span class="fc" id="L41">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L42">    JsonAdapter&lt;List&lt;List&lt;String&gt;&gt;&gt; adapter =</span>
<span class="fc" id="L43">        moshi.adapter(Types.newParameterizedType(List.class, List.class, String.class));</span>

    try {
      // Deserialize the JSON string into a List&lt;List&lt;String&gt;&gt;
<span class="fc" id="L47">      List&lt;List&lt;String&gt;&gt; result = adapter.fromJson(json);</span>
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L49">        throw new IOException(&quot;Result is Empty&quot;);</span>
      }
      // Create an ArrayList from the result
<span class="fc" id="L52">      return new ArrayList&lt;&gt;(result);</span>
<span class="nc" id="L53">    } catch (IOException e) {</span>
<span class="nc" id="L54">      System.err.println(&quot;Error parsing JSON: &quot; + e.getMessage());</span>
<span class="nc" id="L55">      throw e;</span>
    }
  }

  /**
   * This is a secondary method to handle the logic behind deserialization. Functions similarly to
   * fromJson but returns a hash map instead of arrayList (response map) This is used to create the
   * hash map between the States and their respective state codes.
   *
   * @param json JSON String
   * @param hasHeader boolean to see if there is header
   * @return a hashmap with the content provided via the JSON
   * @throws IOException throws an error if the info can't be deserialized
   */
  public static HashMap&lt;String, String&gt; fromJsonMap(String json, Boolean hasHeader)
      throws IOException {
<span class="fc" id="L71">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L72">    JsonAdapter&lt;List&lt;List&lt;String&gt;&gt;&gt; adapter =</span>
<span class="fc" id="L73">        moshi.adapter(Types.newParameterizedType(List.class, List.class, String.class));</span>

    try {
<span class="fc" id="L76">      List&lt;List&lt;String&gt;&gt; result = adapter.fromJson(json);</span>
<span class="fc" id="L77">      HashMap&lt;String, String&gt; responseMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">      if (result == null) {</span>
<span class="fc" id="L79">        throw new IOException(&quot;Result is Empty&quot;);</span>
      }
<span class="fc bfc" id="L81" title="All 2 branches covered.">      if (hasHeader) {</span>
<span class="fc" id="L82">        result.remove(0);</span>
      }
<span class="fc bfc" id="L84" title="All 2 branches covered.">      for (List&lt;String&gt; element : result) {</span>
<span class="fc" id="L85">        responseMap.put(element.get(0), element.get(1));</span>
<span class="fc" id="L86">      }</span>
<span class="fc" id="L87">      return responseMap;</span>
<span class="fc" id="L88">    } catch (IOException e) {</span>
<span class="fc" id="L89">      System.err.println(&quot;Error parsing JSON: &quot; + e.getMessage());</span>
<span class="fc" id="L90">      throw e;</span>
    }
  }

  /**
   * This is our third and final method for deserialization, it has very similar logic to
   * fromJSONMap but is used to create a hash map between counties and their respective county codes
   * instead.
   *
   * @param json JSON String
   * @param hasHeader boolean telling if there was a header
   * @return a hashmap with the content provided via the JSON
   * @throws IOException throws an error if the info can't be deserialized
   */
  public static HashMap&lt;String, String&gt; fromJsonMapCounties(String json, Boolean hasHeader)
      throws IOException {
<span class="fc" id="L106">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L107">    JsonAdapter&lt;List&lt;List&lt;String&gt;&gt;&gt; adapter =</span>
<span class="fc" id="L108">        moshi.adapter(Types.newParameterizedType(List.class, List.class, String.class));</span>
    try {
<span class="fc" id="L110">      List&lt;List&lt;String&gt;&gt; result = adapter.fromJson(json);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">      if (result == null) {</span>
<span class="fc" id="L112">        throw new IOException(&quot;Result is Empty&quot;);</span>
      }
<span class="fc" id="L114">      HashMap&lt;String, String&gt; responseMap = new HashMap&lt;&gt;();</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">      if (hasHeader) {</span>
<span class="fc" id="L116">        result.remove(0);</span>
      }
<span class="fc bfc" id="L118" title="All 2 branches covered.">      for (List&lt;String&gt; element : result) {</span>
<span class="fc" id="L119">        responseMap.put(element.get(0).split(&quot;,&quot;)[0], element.get(2));</span>
<span class="fc" id="L120">        responseMap.put(element.get(0), element.get(2));</span>
<span class="fc" id="L121">      }</span>
<span class="fc" id="L122">      return responseMap;</span>
<span class="fc" id="L123">    } catch (IOException e) {</span>
<span class="fc" id="L124">      System.err.println(&quot;Error parsing JSON: &quot; + e.getMessage());</span>
<span class="fc" id="L125">      throw e;</span>
    }
  }

  /**
   * This is our main method for serialization. It is used to serialize a container objects data and
   * display it on our server page. Utilized for viewCSV and searchCSV endpoints
   *
   * @param container container object from parse to be serialized
   * @return A JSON String containing the data provided
   * @throws IOException throws an error if the info can't be deserialized
   */
  public static String toJson(Container&lt;List&lt;String&gt;&gt; container) throws IOException {
<span class="fc" id="L138">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L139">    Type mapStringObject = Types.newParameterizedType(Map.class, String.class, Object.class);</span>
<span class="fc" id="L140">    JsonAdapter&lt;Map&lt;String, Object&gt;&gt; adapter = moshi.adapter(mapStringObject);</span>
<span class="fc" id="L141">    Map&lt;String, Object&gt; responseMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L142">    JsonAdapter&lt;Boolean&gt; hasHeaderData = moshi.adapter(Boolean.class);</span>
<span class="fc" id="L143">    responseMap.put(&quot;return Type&quot;, &quot;success&quot;);</span>
<span class="fc" id="L144">    responseMap.put(&quot;hasHeader&quot;, hasHeaderData.toJson(container.hasHeader));</span>

    // Process the header to remove double quotes
<span class="fc" id="L147">    List&lt;String&gt; processedHeader = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">    for (String headerItem : container.header) {</span>
<span class="fc" id="L149">      processedHeader.add(headerItem.replace(&quot;\&quot;&quot;, &quot;&quot;));</span>
<span class="fc" id="L150">    }</span>

<span class="fc" id="L152">    responseMap.put(&quot;header&quot;, processedHeader);</span>
<span class="fc" id="L153">    responseMap.put(&quot;Time&quot;, LocalDateTime.now().toString());</span>

    // Process the rows to remove double quotes
<span class="fc" id="L156">    List&lt;List&lt;String&gt;&gt; processedRows = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">    for (List&lt;String&gt; row : container.rows) {</span>
<span class="fc" id="L158">      List&lt;String&gt; processedRow = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      for (String rowItem : row) {</span>
<span class="fc" id="L160">        processedRow.add(rowItem.replace(&quot;\&quot;&quot;, &quot;&quot;));</span>
<span class="fc" id="L161">      }</span>
<span class="fc" id="L162">      processedRows.add(processedRow);</span>
<span class="fc" id="L163">    }</span>

<span class="fc" id="L165">    responseMap.put(&quot;data&quot;, processedRows);</span>

<span class="fc" id="L167">    return prettyJson(adapter.toJson(responseMap));</span>
  }

  /**
   * This is a secondary method for serialization that uses method overload to do serialization on a
   * List of List of Strings as opposed to a container object. Utilized for broadBand handling.
   *
   * @param rows List of List of Strings to be serialized
   * @return A JSON String containing the data provided
   * @throws IOException throws an error if the info can't be serialized
   */
  public static String toJson(ArrayList&lt;List&lt;String&gt;&gt; rows) throws IOException {
<span class="fc" id="L179">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L180">    Type mapStringObject = Types.newParameterizedType(Map.class, String.class, Object.class);</span>
<span class="fc" id="L181">    Map&lt;String, Object&gt; responseMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L182">    responseMap.put(&quot;return Type&quot;, &quot;success&quot;);</span>
<span class="fc" id="L183">    responseMap.put(&quot;Time&quot;, LocalDateTime.now().toString());</span>
<span class="fc" id="L184">    JsonAdapter&lt;Map&lt;String, Object&gt;&gt; adapter = moshi.adapter(mapStringObject);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">    if (rows.size() == 2) {</span>
<span class="fc" id="L186">      List&lt;String&gt; header = rows.remove(0);</span>
<span class="fc" id="L187">      List&lt;String&gt; info = rows.remove(0);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      for (String column : header) {</span>
<span class="fc" id="L189">        responseMap.put(column, info.get(header.indexOf(column)));</span>
<span class="fc" id="L190">      }</span>
<span class="fc" id="L191">    } else {</span>
<span class="nc" id="L192">      responseMap.put(&quot;data&quot;, rows);</span>
    }
<span class="fc" id="L194">    return prettyJson(adapter.toJson(responseMap));</span>
  }

  /**
   * This is a method to handle the actual display of our JSONâ€™s within our server. We have made it
   * so that the JSON provided to the user is readable and looks nice.
   *
   * @param json JSON String
   * @return formatted JSON String
   * @throws IOException throws an error if the info can't be serialized
   */
  public static String prettyJson(String json) throws IOException {
<span class="fc" id="L206">    Buffer source = new Buffer().writeUtf8(json);</span>
<span class="fc" id="L207">    JsonReader reader = JsonReader.of(source);</span>
<span class="fc" id="L208">    Object value = reader.readJsonValue();</span>
<span class="fc" id="L209">    JsonAdapter&lt;Object&gt; adapter = new Moshi.Builder().build().adapter(Object.class).indent(&quot;    &quot;);</span>
<span class="fc" id="L210">    return adapter.toJson(value);</span>
  }

  /**
   * This is a method to handle certain responses that only return failure or success responses
   * without any actual data. This is mainly utilized in our defensive programing where we catch the
   * errors that may be thrown and use toJSONStatus to display that to out users in a sensible way.
   *
   * @param reason reason for failure
   * @param failed boolean to see if failed
   * @return JSON String with reason for failure or success
   * @throws IOException throws an error if the info can't be serialized
   */
  public static String toJsonStatus(String reason, Boolean failed) throws IOException {
<span class="fc" id="L224">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L225">    Type mapStringObject = Types.newParameterizedType(Map.class, String.class, Object.class);</span>
<span class="fc" id="L226">    JsonAdapter&lt;Map&lt;String, Object&gt;&gt; adapter = moshi.adapter(mapStringObject);</span>
<span class="fc" id="L227">    Map&lt;String, Object&gt; responseMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (failed) {</span>
<span class="fc" id="L229">      responseMap.put(&quot;return Type&quot;, &quot;Failure&quot;);</span>
<span class="fc" id="L230">      responseMap.put(&quot;reason&quot;, reason);</span>
    } else {
<span class="fc" id="L232">      responseMap.put(&quot;return Type&quot;, &quot;Success&quot;);</span>
    }
<span class="fc" id="L234">    return prettyJson(adapter.toJson(responseMap));</span>
  }

  /**
   * This is a general JSON serializer that could theoretically be used to change any given type to
   * JSON String. (This is for other developers' use)
   *
   * @param object generic object to serialize
   * @return JSON String for given object(data)
   * @throws IllegalAccessException thrown if the serialization goes wrong
   */
  public String toJsonGeneral(T object) throws IllegalAccessException {
<span class="nc" id="L246">    Field[] fields = object.getClass().getDeclaredFields();</span>

<span class="nc" id="L248">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="nc" id="L249">    Type mapStringObject = Types.newParameterizedType(Map.class, String.class, Object.class);</span>
<span class="nc" id="L250">    JsonAdapter&lt;Map&lt;String, Object&gt;&gt; adapter = moshi.adapter(mapStringObject);</span>

<span class="nc" id="L252">    Map&lt;String, Object&gt; responseMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L253">    responseMap.put(&quot;return Type&quot;, &quot;success&quot;);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">    for (Field field : fields) {</span>
<span class="nc" id="L255">      responseMap.put(field.getName(), field.get(object));</span>
    }
<span class="nc" id="L257">    return adapter.toJson(responseMap);</span>
  }

  public static &lt;T&gt; T fromJsonGeneral(JsonReader source, Class&lt;T&gt; targetType) throws IOException {
<span class="fc" id="L261">    Moshi moshi = new Moshi.Builder().build();</span>
<span class="fc" id="L262">    JsonAdapter&lt;T&gt; adapter = moshi.adapter(targetType);</span>
<span class="fc" id="L263">    source.setLenient(true);</span>

<span class="fc" id="L265">    return adapter.fromJson(source);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>